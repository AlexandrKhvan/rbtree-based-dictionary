Тут читаем что вообще происходит в коде

## 1. Техническое задание (ТЗ)

### 1.1. Цель

Реализовать словарь, хранящий слова в лексикографическом порядке, поддерживающий операции добавления, удаления, поиска и редактирования, а также специфические функции (синонимы, автодополнение).

### 1.2. Функциональные требования

- Базовые операции: Поиск, Вставка, Удаление, Переименование слов.

- Балансировка: Дерево должно автоматически балансироваться после изменений, сохраняя логарифмическую сложность операций.

- Синонимы: Возможность связывать слова как синонимы.

- Важное условие: Синонимы должны храниться как ссылки (указатели) на другие узлы дерева, а не дублировать строки.

- Поиск по префиксу: Вывод всех слов, начинающихся с заданной подстроки.

- Файловый ввод/вывод: Сохранение состояния словаря между запусками.

### 1.3. Ограничения

- Максимальная длина слова: 30 символов.

- Максимальное количество синонимов у слова: 10.

- Максимальная глубина дерева (теоретическая): 20.

- Отсутствие дубликатов.

## 2. Теоретическая справка: Красно-Черное Дерево

Часть где надо немного включить голову, сорри, но так надо, иначе не понять что происходит. 

Для реализации словаря заданием было выбрано Красно-Черное дерево. Из плюсов - оно гарантирует временную сложность $O(log N)$ для основных операций (поиск, вставка, удаление), даже в самом худшем случае.

Как бинарное дерево, красно-черное обладает свойствами:

- Оба поддерева являются бинарными деревьями поиска.

- Для каждого узла с ключом $k$ выполняется критерий упорядочения: ключи всех левых потомков <= $k$ < ключи всех правых потомков (в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать). Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.

Свойства уже конкретно красно-черных деревьев:

- Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).

- Корень окрашен в черный цвет.

- Листья (это узлы без потомков) окрашены в черный цвет.

- Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.

- Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это так называемая черная высота).

Эти свойства гарантируют, что самое длинное ветвление не более чем в два раза длиннее самого короткого, что делает дерево приближенно сбалансированным (отсюда же и log N сложность для операций). 

Посмотрим, почему это так. Пусть у нас есть красно-черное дерево. Черная высота равна $bh$ (black height). Если путь от корневого узла до листового содержит минимальное количество красных узлов (т.е. ноль), значит этот путь равен $bh$. Если же путь содержит максимальное количество красных узлов ($bh$ в соответствии со свойствами), то этот путь будет равен $2bh$. То есть, пути из корня к листьям могут различаться не более, чем вдвое ($h \leq 2*log(N + 1)$, где h — высота поддерева), а этого достаточно, чтобы время выполнения операций в таком дереве было $O(log N)$.

Вообще можно почитать поподробнее про них, но нам этого хватит.

## 3. Архитектура Проекта

Код разделен на логические блоки для упрощения нашей итак нелегкой жизни.
 
### 3.1. Структура файлов

include/: Папка с заголовочными файлами (.h). Содержит описания структур и прототипы функций. Это интерфейс модулей.

src/: Папка с исходным кодом (.c).

Ну то бишь в include мы объявили все константы, базовые структуры и их методы, а в src уже непосредственно реализовали все, что заявлено в include.

Итак, по файлам:

- rbtree.c: "Движок" дерева. Содержит только логику RBT (все базу и операции поворотов, балансировки).

- dict.c: Уже сам словарь, на основе дерева. Содержит функции работы с синонимами, файлами и поиском.

- main.c: Точка входа, меню пользователя и связывание модулей.

### 3.2. Структура данных (Node)

Ключевой элемент системы — структура узла:

```
typedef struct Node {
    char word[MAX_WORD_LEN + 1];           // Ключ (само слово)
    Color color;                           // Цвет (RED/BLACK)
    struct Node *left, *right;             // Дети
    struct Node *parent;                   // Родитель
    
    struct Node *synonyms[MAX_SYNONYMS];   // Массив УКАЗАТЕЛЕЙ на другие узлы
    int synonym_count;                     // Текущее количество синонимов
} Node;
```

## 4. Детали реализации операций 

### 4.1. Балансировка (Вставка)

При вставке нового узла он всегда окрашивается в Красный цвет. Это может нарушить свойство "нет двух красных подряд". Алгоритм insertFixup исправляет это двумя способами:

- Перекраска: Если "дядя" узла тоже красный, мы меняем цвета отца, дяди и деда.

- Повороты (Rotations): Если "дядя" черный (ахахаххахаха бля), мы выполняем левый или правый поворот дерева, чтобы изменить структуру и восстановить баланс.

### 4.2. Удаление и целостность данных

Удаление — самая сложная операция в RBT, требующая восстановления "черной высоты". Однако в нашем ТЗ есть дополнительная сложность - синонимы.

Проблема то в чём. Узел А может хранить указатель на Узел Б как на синоним. Если мы удалим Узел Б, то у Узла А останется "висячий указатель" (а когда висит что-то это плохо так сказать), что приведет к краху программы при попытке доступа, ну или в лучшем случае просто утечет память.

Решение этой неприятной ситуации у нас такое - реализована функция cleanAllReferencesTo(Node *target).
Перед тем как физически освободить память (free) удаляемого узла, программа обходит дерево (или проверяет связанные списки) и принудительно удаляет указатель на этот узел из массивов синонимов всех остальных слов. Да, это немного усложнит код, но зато все будет стабильно и правильно.

### 4.3. Файловый ввод/вывод (Персистентность)

Сохранение указателей в файл невозможно, так как при следующем запуске адреса памяти изменятся, и ничего мы не сохраним по итогу.

Поэтому алгоритм сохранения такой:

- Обход дерева.

- Запись слова-ключа.

- Запись слов-синонимов (строками, а не адресами).

Ну и алгоритм загрузки (Двухпроходный метод):

- Проход 1: Читаем файл, извлекаем только первые слова строк и строим структуру дерева (insert). На этом этапе синонимы игнорируются.

- Проход 2: Читаем файл заново. Теперь, когда все узлы уже созданы в памяти, мы ищем их по названиям и устанавливаем связи указателей (addSynonym).

### 4.4. Поиск по префиксу

Реализован рекурсивный обход дерева. Поскольку дерево упорядочено лексикографически, можно было бы оптимизировать поиск диапазона, но для текущих ограничений (глубина 20) полный обход с проверкой strncmp работает достаточно эффективно, поэтому похуй+похуй.

## 5. Сборка проекта

Для автоматизации компиляции используется утилита Make.
Makefile автоматически отслеживает изменения в .c и .h файлах и перекомпилирует только измененные модули, собирая их в итоговый бинарный файл dictionary_app.

Команды:
```
make // сборка/перекомпиляция проекта. после этого следующей соответствующей командой уже запускаем программу.

make clean // очистка временных файлов.

./dictionary_app // запуск для Linux/WSL

.\dictionary_app.exe //запуск под виндой

```

Есть также рофл с виндоусной консолью - она иногда не выводит русский язык внутри консоли. Поэтому, если столкнулись, то делаем следующее - в консоль вставляем команду из файла blabla.txt, потом make clean, потом make, и потом .\dictionary_app.exe.
## 6. Выводы

Прога - это магия. Учитесь прогать, дети мои
